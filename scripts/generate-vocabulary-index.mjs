import fs from "node:fs";
import path from "node:path";

/**
 * Generates `lib/vocabulary/index.ts` by auto-discovering `collection_*.ts` files.
 * This guarantees new collections are picked up without manual registration.
 */

const workspaceRoot = process.cwd();
const vocabDir = path.join(workspaceRoot, "lib", "vocabulary");
const outFile = path.join(vocabDir, "index.ts");

/** @param {string} fileName */
function parseCollectionNumber(fileName) {
  const m = /^collection_(\d+)\.ts$/i.exec(fileName);
  if (!m) return null;
  return Number(m[1]);
}

const files = fs
  .readdirSync(vocabDir, { withFileTypes: true })
  .filter((d) => d.isFile())
  .map((d) => d.name)
  .filter((name) => /^collection_\d+\.ts$/i.test(name))
  .map((name) => ({ name, n: parseCollectionNumber(name) ?? Number.POSITIVE_INFINITY }))
  .sort((a, b) => a.n - b.n);

if (files.length === 0) {
  throw new Error(`No collection files found in ${vocabDir}`);
}

const importLines = files.map(({ name }, idx) => {
  const base = name.replace(/\.ts$/i, "");
  return `import c${idx} from "./${base}"`;
});

const arrayLines = files.map((_, idx) => `  c${idx},`);

const content = `/* eslint-disable */
// This file is auto-generated by \`scripts/generate-vocabulary-index.mjs\`.
// Do not edit manually.

import type { VocabularyCollection } from "../utils"
${importLines.join("\n")}

export const VOCABULARY_COLLECTIONS: VocabularyCollection[] = [
${arrayLines.join("\n")}
]
`;

fs.writeFileSync(outFile, content, "utf8");
console.log(
  `[vocab:generate] Wrote ${path.relative(workspaceRoot, outFile)} with ${files.length} collections.`
);


